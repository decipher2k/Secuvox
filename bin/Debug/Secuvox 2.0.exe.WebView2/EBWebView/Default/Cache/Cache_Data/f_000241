{"version":3,"sources":["webpack://@cleverpush/cleverpush-js-sdk/./src/utils/penpal.js"],"names":["id","HANDSHAKE","HANDSHAKE_REPLY","CALL","REPLY","FULFILLED","REJECTED","MESSAGE","ERR_CONNECTION_DESTROYED","ERR_CONNECTION_TIMEOUT","ERR_NOT_IN_IFRAME","ERR_IFRAME_ALREADY_ATTACHED_TO_DOM","DEFAULT_PORTS","URL_REGEX","Penpal","Promise","window","e","debug","generateId","log","args","console","DestructionPromise","executor","handlers","forEach","handler","then","push","serializeError","name","message","stack","deserializeError","obj","deserializedError","Error","Object","keys","key","connectCallSender","callSender","info","methodNames","destroy","destructionPromise","localName","local","remote","remoteOrigin","destroyed","reduce","api","methodName","closed","error","code","resolve","reject","addEventListener","handleMessageEvent","event","source","origin","data","penpal","removeEventListener","returnValue","returnValueIsError","resolution","postMessage","createMethodProxy","connectCallReceiver","methods","createPromiseHandler","err","apply","connectToChild","url","appendTo","iframe","timeout","childWindow","parentNode","connectionDestructionPromise","resolveConnectionDestructionPromise","parent","document","createElement","src","childOrigin","protocol","hostname","port","location","regexResult","exec","portSuffix","getOriginFromUrl","promise","resolveConnectionPromise","connectionTimeoutId","undefined","setTimeout","receiverMethodNames","destroyCallReceiver","handleMessage","child","contentWindow","callReceiverDestructionPromise","resolveCallReceiverDestructionPromise","receiverMethodName","clearTimeout","body","appendChild","checkIframeInDocIntervalId","setInterval","contains","clearInterval","removeChild","connectToParent","parentOrigin","parentWindow","top","opener"],"mappings":"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","file":"chunk/251.ff5b3c0c290e9961835b.js","sourcesContent":["const HANDSHAKE = 'handshake';\nconst HANDSHAKE_REPLY = 'handshake-reply';\nconst CALL = 'call';\nconst REPLY = 'reply';\nconst FULFILLED = 'fulfilled';\nconst REJECTED = 'rejected';\nconst MESSAGE = 'message';\nconst DATA_CLONE_ERROR = 'DataCloneError';\n\nexport const ERR_CONNECTION_DESTROYED = 'ConnectionDestroyed';\nexport const ERR_CONNECTION_TIMEOUT = 'ConnectionTimeout';\nexport const ERR_NOT_IN_IFRAME = 'NotInIframe';\nexport const ERR_IFRAME_ALREADY_ATTACHED_TO_DOM = 'IframeAlreadyAttachedToDom';\n\nconst CHECK_IFRAME_IN_DOC_INTERVAL = 60000;\n\nconst DEFAULT_PORTS = {\n  'http:': '80',\n  'https:': '443'\n};\n\nconst URL_REGEX = /^(https?:|file:)?\\/\\/([^/:]+)?(:(\\d+))?/;\n\nconst Penpal = {\n  ERR_CONNECTION_DESTROYED,\n  ERR_CONNECTION_TIMEOUT,\n  ERR_NOT_IN_IFRAME,\n  ERR_IFRAME_ALREADY_ATTACHED_TO_DOM,\n\n  /**\n   * Promise implementation.\n   * @type {Constructor}\n   */\n  Promise: (() => {\n    try {\n      return window ? window.Promise : null;\n    } catch (e) {\n      return null;\n    }\n  })(),\n  /**\n   * Whether debug messages should be logged.\n   * @type {boolean}\n   */\n  debug: false\n};\n\n/**\n * @return {number} A unique ID (not universally unique)\n */\nconst generateId = (() => {\n  let id = 0;\n  return () => ++id;\n})();\n\n/**\n * Logs a message.\n * @param {...*} args One or more items to log\n */\nconst log = (...args) => {\n  if (Penpal.debug) {\n    console.log('[CleverPush][Penpal]', ...args); // eslint-disable-line no-console\n  }\n};\n\n/**\n * Converts a URL into an origin.\n * @param {string} url\n * @return {string} The URL's origin\n */\nconst getOriginFromUrl = (url) => {\n  const location = document.location;\n\n  const regexResult = URL_REGEX.exec(url);\n  let protocol;\n  let hostname;\n  let port;\n\n  if (regexResult) {\n    // It's an absolute URL. Use the parsed info.\n    // regexResult[1] will be undefined if the URL starts with //\n    protocol = regexResult[1] ? regexResult[1] : location.protocol;\n    hostname = regexResult[2];\n    port = regexResult[4];\n  } else {\n    // It's a relative path. Use the current location's info.\n    protocol = location.protocol;\n    hostname = location.hostname;\n    port = location.port;\n  }\n\n  // If the protocol is file, the origin is \"null\"\n  // The origin of a document with file protocol is an opaque origin\n  // and its serialization \"null\" [1]\n  // [1] https://html.spec.whatwg.org/multipage/origin.html#origin\n  if (protocol === 'file:') {\n    return 'null';\n  }\n\n  // If the port is the default for the protocol, we don't want to add it to the origin string\n  // or it won't match the message's event.origin.\n  const portSuffix = port && port !== DEFAULT_PORTS[protocol] ? `:${port}` : '';\n  return `${protocol}//${hostname}${portSuffix}`;\n};\n\n/**\n * A simplified promise class only used internally for when destroy() is called. This is\n * used to destroy connections synchronously while promises typically resolve asynchronously.\n *\n * @param {Function} executor\n * @returns {Object}\n * @constructor\n */\nconst DestructionPromise = (executor) => {\n  const handlers = [];\n\n  executor(() => {\n    handlers.forEach((handler) => {\n      handler();\n    });\n  });\n\n  return {\n    then(handler) {\n      handlers.push(handler);\n    }\n  };\n};\n\n/**\n * Converts an error object into a plain object.\n * @param {Error} Error object.\n * @returns {Object}\n */\nconst serializeError = ({ name, message, stack }) => ({ name, message, stack });\n\n/**\n * Converts a plain object into an error object.\n * @param {Object} Object with error properties.\n * @returns {Error}\n */\nconst deserializeError = (obj) => {\n  const deserializedError = new Error();\n  Object.keys(obj).forEach((key) => (deserializedError[key] = obj[key]));\n  return deserializedError;\n};\n\n/**\n * Augments an object with methods that match those defined by the remote. When these methods are\n * called, a \"call\" message will be sent to the remote, the remote's corresponding method will be\n * executed, and the method's return value will be returned via a message.\n * @param {Object} callSender Sender object that should be augmented with methods.\n * @param {Object} info Information about the local and remote windows.\n * @param {Array} methodNames Names of methods available to be called on the remote.\n * @param {Promise} destructionPromise A promise resolved when destroy() is called on the penpal\n * connection.\n * @returns {Object} The call sender object with methods that may be called.\n */\nconst connectCallSender = (\n  callSender,\n  info,\n  methodNames,\n  destroy,\n  destructionPromise\n) => {\n  const {\n    localName, local, remote, remoteOrigin\n  } = info;\n  let destroyed = false;\n\n  log(`${localName}: Connecting call sender`);\n\n  const createMethodProxy = (methodName) => (...args) => {\n    log(`${localName}: Sending ${methodName}() call`);\n\n    // This handles the case where the iframe has been removed from the DOM\n    // (and therefore its window closed), the consumer has not yet\n    // called destroy(), and the user calls a method exposed by\n    // the remote. We detect the iframe has been removed and force\n    // a destroy() immediately so that the consumer sees the error saying\n    // the connection has been destroyed.\n    if (remote.closed) {\n      destroy();\n    }\n\n    if (destroyed) {\n      const error = new Error(\n        `Unable to send ${methodName}() call due ` + 'to destroyed connection'\n      );\n      error.code = ERR_CONNECTION_DESTROYED;\n      throw error;\n    }\n\n    return new Penpal.Promise((resolve, reject) => {\n      const id = generateId();\n      const handleMessageEvent = (event) => {\n        if (\n          event.source === remote\n            && event.origin === remoteOrigin\n            && event.data.penpal === REPLY\n            && event.data.id === id\n        ) {\n          log(`${localName}: Received ${methodName}() reply`);\n          local.removeEventListener(MESSAGE, handleMessageEvent);\n\n          let returnValue = event.data.returnValue;\n\n          if (event.data.returnValueIsError) {\n            returnValue = deserializeError(returnValue);\n          }\n\n          (event.data.resolution === FULFILLED ? resolve : reject)(\n            returnValue\n          );\n        }\n      };\n\n      local.addEventListener(MESSAGE, handleMessageEvent);\n      remote.postMessage(\n        {\n          penpal: CALL,\n          id,\n          methodName,\n          args\n        },\n        remoteOrigin\n      );\n    });\n  };\n\n  destructionPromise.then(() => {\n    destroyed = true;\n  });\n\n  methodNames.reduce((api, methodName) => {\n    api[methodName] = createMethodProxy(methodName);\n    return api;\n  }, callSender);\n};\n\n/**\n * Listens for \"call\" messages coming from the remote, executes the corresponding method, and\n * responds with the return value.\n * @param {Object} info Information about the local and remote windows.\n * @param {Object} methods The keys are the names of the methods that can be called by the remote\n * while the values are the method functions.\n * @param {Promise} destructionPromise A promise resolved when destroy() is called on the penpal\n * connection.\n * @returns {Function} A function that may be called to disconnect the receiver.\n */\nconst connectCallReceiver = (info, methods, destructionPromise) => {\n  const {\n    localName, local, remote, remoteOrigin\n  } = info;\n  let destroyed = false;\n\n  log(`${localName}: Connecting call receiver`);\n\n  const handleMessageEvent = (event) => {\n    if (\n      event.source === remote\n      && event.origin === remoteOrigin\n      && event.data.penpal === CALL\n    ) {\n      const { methodName, args, id } = event.data;\n\n      log(`${localName}: Received ${methodName}() call`);\n\n      if (methodName in methods) {\n        const createPromiseHandler = (resolution) => (returnValue) => {\n          log(`${localName}: Sending ${methodName}() reply`);\n\n          if (destroyed) {\n            // It's possible to throw an error here, but it would need to be thrown asynchronously\n            // and would only be catchable using window.onerror. This is because the consumer\n            // is merely returning a value from their method and not calling any function\n            // that they could wrap in a try-catch. Even if the consumer were to catch the error,\n            // the value of doing so is questionable. Instead, we'll just log a message.\n            log(\n              `${localName}: Unable to send ${methodName}() reply due to destroyed connection`\n            );\n            return;\n          }\n\n          const message = {\n            penpal: REPLY,\n            id,\n            resolution,\n            returnValue\n          };\n\n          if (resolution === REJECTED && returnValue instanceof Error) {\n            message.returnValue = serializeError(returnValue);\n            message.returnValueIsError = true;\n          }\n\n          try {\n            remote.postMessage(message, remoteOrigin);\n          } catch (err) {\n            // If a consumer attempts to send an object that's not cloneable (e.g., window),\n            // we want to ensure the receiver's promise gets rejected.\n            if (err.name === DATA_CLONE_ERROR) {\n              remote.postMessage(\n                {\n                  penpal: REPLY,\n                  id,\n                  resolution: REJECTED,\n                  returnValue: serializeError(err),\n                  returnValueIsError: true\n                },\n                remoteOrigin\n              );\n            }\n\n            throw err;\n          }\n        };\n\n        new Penpal.Promise((resolve) => resolve(methods[methodName].apply(methods, args))).then(createPromiseHandler(FULFILLED), createPromiseHandler(REJECTED));\n      }\n    }\n  };\n\n  local.addEventListener(MESSAGE, handleMessageEvent);\n\n  destructionPromise.then(() => {\n    destroyed = true;\n    local.removeEventListener(MESSAGE, handleMessageEvent);\n  });\n};\n\n/**\n * @typedef {Object} Child\n * @property {Promise} promise A promise which will be resolved once a connection has\n * been established.\n * @property {HTMLIframeElement} iframe The created iframe element.\n * @property {Function} destroy A method that, when called, will remove the iframe element from\n * the DOM and clean up event listeners.\n */\n\n/**\n * Creates an iframe, loads a webpage into the URL, and attempts to establish communication with\n * the iframe.\n * @param {Object} options\n * @param {string} options.url The URL of the webpage that should be loaded into the created iframe.\n * @param {HTMLElement} [options.appendTo] The container to which the iframe should be appended.\n * @param {Object} [options.methods={}] Methods that may be called by the iframe.\n * @param {Number} [options.timeout] The amount of time, in milliseconds, Penpal should wait\n * for the child to respond before rejecting the connection promise.\n * @return {Child}\n */\nPenpal.connectToChild = ({\n  url, appendTo, iframe, methods = {}, timeout, childWindow\n}) => {\n  if (iframe && iframe.parentNode) {\n    const error = new Error(\n      'connectToChild() must not be called with an iframe already attached to DOM'\n    );\n    error.code = ERR_IFRAME_ALREADY_ATTACHED_TO_DOM;\n    throw error;\n  }\n\n  let destroy;\n\n  const connectionDestructionPromise = new DestructionPromise(\n    (resolveConnectionDestructionPromise) => {\n      destroy = resolveConnectionDestructionPromise;\n    }\n  );\n\n  const parent = window;\n\n  if (!childWindow) {\n    iframe = iframe || document.createElement('iframe');\n    iframe.src = url;\n  }\n\n  const childOrigin = getOriginFromUrl(url);\n  const promise = new Penpal.Promise((resolveConnectionPromise, reject) => {\n    let connectionTimeoutId;\n\n    if (timeout !== undefined) {\n      connectionTimeoutId = setTimeout(() => {\n        const error = new Error(\n          `Connection to child timed out after ${timeout}ms`\n        );\n        error.code = ERR_CONNECTION_TIMEOUT;\n        reject(error);\n        destroy();\n      }, timeout);\n    }\n\n    // We resolve the promise with the call sender. If the child reconnects (for example, after\n    // refreshing or navigating to another page that uses Penpal, we'll update the call sender\n    // with methods that match the latest provided by the child.\n    const callSender = {};\n    let receiverMethodNames;\n\n    let destroyCallReceiver;\n\n    const handleMessage = (event) => {\n      const child = childWindow || iframe.contentWindow;\n      if (\n        event.source === child\n        && event.origin === childOrigin\n        && event.data.penpal === HANDSHAKE\n      ) {\n        log('Parent: Received handshake, sending reply');\n\n        // If event.origin is \"null\", the remote protocol is file:\n        // and we must post messages with \"*\" as targetOrigin [1]\n        // [1] https://developer.mozilla.org/fr/docs/Web/API/Window/postMessage#Utiliser_window.postMessage_dans_les_extensions\n        const remoteOrigin = event.origin === 'null' ? '*' : event.origin;\n\n        event.source.postMessage(\n          {\n            penpal: HANDSHAKE_REPLY,\n            methodNames: Object.keys(methods)\n          },\n          remoteOrigin\n        );\n\n        const info = {\n          localName: 'Parent',\n          local: parent,\n          remote: child,\n          remoteOrigin\n        };\n\n        // If the child reconnected, we need to destroy the previous call receiver before setting\n        // up a new one.\n        if (destroyCallReceiver) {\n          destroyCallReceiver();\n        }\n\n        // When this promise is resolved, it will destroy the call receiver (stop listening to\n        // method calls from the child) and delete its methods off the call sender.\n        const callReceiverDestructionPromise = new DestructionPromise(\n          (resolveCallReceiverDestructionPromise) => {\n            connectionDestructionPromise.then(\n              resolveCallReceiverDestructionPromise\n            );\n            destroyCallReceiver = resolveCallReceiverDestructionPromise;\n          }\n        );\n\n        connectCallReceiver(info, methods, callReceiverDestructionPromise);\n\n        // If the child reconnected, we need to remove the methods from the previous call receiver\n        // off the sender.\n        if (receiverMethodNames) {\n          receiverMethodNames.forEach((receiverMethodName) => {\n            delete callSender[receiverMethodName];\n          });\n        }\n\n        receiverMethodNames = event.data.methodNames;\n        connectCallSender(\n          callSender,\n          info,\n          receiverMethodNames,\n          destroy,\n          connectionDestructionPromise\n        );\n        clearTimeout(connectionTimeoutId);\n        resolveConnectionPromise(callSender);\n      }\n    };\n\n    parent.addEventListener(MESSAGE, handleMessage);\n\n    if (!childWindow) {\n      log('Parent: Loading iframe');\n      (appendTo || document.body).appendChild(iframe);\n\n      // This is to prevent memory leaks when the iframe is removed\n      // from the document and the consumer hasn't called destroy().\n      // Without this, event listeners attached to the window would\n      // stick around and since the event handlers have a reference\n      // to the iframe in their closures, the iframe would stick around\n      // too.\n      var checkIframeInDocIntervalId = setInterval(() => {\n        if (!document.body.contains(iframe)) {\n          clearInterval(checkIframeInDocIntervalId);\n          destroy();\n        }\n      }, CHECK_IFRAME_IN_DOC_INTERVAL);\n\n      connectionDestructionPromise.then(() => {\n        if (iframe.parentNode) {\n          iframe.parentNode.removeChild(iframe);\n        }\n\n        parent.removeEventListener(MESSAGE, handleMessage);\n        clearInterval(checkIframeInDocIntervalId);\n\n        const error = new Error('Connection destroyed');\n        error.code = ERR_CONNECTION_DESTROYED;\n        reject(error);\n      });\n    }\n  });\n\n  return {\n    promise,\n    iframe,\n    destroy\n  };\n};\n\n/**\n * @typedef {Object} Parent\n * @property {Promise} promise A promise which will be resolved once a connection has\n * been established.\n */\n\n/**\n * Attempts to establish communication with the parent window.\n * @param {Object} options\n * @param {string} [options.parentOrigin=*] Valid parent origin used to restrict communication.\n * @param {Object} [options.methods={}] Methods that may be called by the parent window.\n * @param {Number} [options.timeout] The amount of time, in milliseconds, Penpal should wait\n * for the parent to respond before rejecting the connection promise.\n * @return {Parent}\n */\nPenpal.connectToParent = ({\n  parentOrigin = '*',\n  methods = {},\n  timeout,\n  parentWindow,\n} = {}) => {\n  if (window === window.top && !window.opener) {\n    const error = new Error(\n      'connectToParent() must be called within an iframe'\n    );\n    error.code = ERR_NOT_IN_IFRAME;\n    throw error;\n  }\n\n  let destroy;\n  const connectionDestructionPromise = new DestructionPromise(\n    (resolveConnectionDestructionPromise) => {\n      destroy = resolveConnectionDestructionPromise;\n    }\n  );\n\n  const child = window;\n  const parent = parentWindow || child.parent;\n\n  const promise = new Penpal.Promise((resolveConnectionPromise, reject) => {\n    let connectionTimeoutId;\n\n    if (timeout !== undefined) {\n      connectionTimeoutId = setTimeout(() => {\n        const error = new Error(\n          `Connection to parent timed out after ${timeout}ms`\n        );\n        error.code = ERR_CONNECTION_TIMEOUT;\n        reject(error);\n        destroy();\n      }, timeout);\n    }\n\n    const handleMessageEvent = (event) => {\n      if (\n        (parentOrigin === '*' || parentOrigin === event.origin)\n        && event.source === parent\n        && event.data.penpal === HANDSHAKE_REPLY\n      ) {\n        log('Child: Received handshake reply');\n\n        child.removeEventListener(MESSAGE, handleMessageEvent);\n\n        const info = {\n          localName: 'Child',\n          local: child,\n          remote: parent,\n          remoteOrigin: event.origin\n        };\n\n        const callSender = {};\n\n        connectCallReceiver(info, methods, connectionDestructionPromise);\n        connectCallSender(\n          callSender,\n          info,\n          event.data.methodNames,\n          destroy,\n          connectionDestructionPromise\n        );\n        clearTimeout(connectionTimeoutId);\n        resolveConnectionPromise(callSender);\n      }\n    };\n\n    child.addEventListener(MESSAGE, handleMessageEvent);\n\n    connectionDestructionPromise.then(() => {\n      child.removeEventListener(MESSAGE, handleMessageEvent);\n\n      const error = new Error('Connection destroyed');\n      error.code = ERR_CONNECTION_DESTROYED;\n      reject(error);\n    });\n\n    log('Child: Sending handshake');\n\n    parent.postMessage(\n      {\n        penpal: HANDSHAKE,\n        methodNames: Object.keys(methods)\n      },\n      parentOrigin\n    );\n  });\n\n  return {\n    promise,\n    destroy\n  };\n};\n\nexport default Penpal;\n"],"sourceRoot":""}